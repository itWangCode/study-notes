# 贪心算法

<https://juejin.im/post/6844903895748067341#comment>

贪心算法是动态规划算法的一个子集，可以更高效解决一部分更特殊的问题。实际上，用贪心算法解决问题的思路，并不总能给出最优解。因为它在每一步的决策中，选择目前最优策略，不考虑全
局是不是最优。

运用贪心策略在每一次转化时都取得了最优解。

问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。

贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。

贪心算法对每个子问题的解决方案都做出选择，不能回退；

动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题

## 思路

指标存到数组， for/while 迭代处理

## 题目: 发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

将需求因子 g 和 s 分别从小到大进行排序，使用贪心思想配合双指针，每个饼干只尝试一次，成功则换下一个孩子来尝试。

```js
const findContentChildren = (g, s) => {
  if (!g.length || !s.length) return 0

  g.sort((a, b) => a - b) // g: 胃口数组
  s.sort((a, b) => a - b) // s: 饼干尺寸数组
  
  let gi = 0, // 胃口值
      si = 0; // 饼干尺寸 
  while (gi < g.length && si < s.length) { // 循环处理，胃口 和 尺寸从 索引0逐渐增大
    if (g[gi] <= s[si++]) gi++
  }
  return gi
}
```

## 题目：钱币找零问题

这是生活中很常见的问题,你的钱包中有1元,5元,10元,50元,100元,分别为a1张,a2张,a3张,a4张,a5张,你需要用这些钱去支付y元,至少需要多少张纸币.贪心算法来计算的话,很明显,每一次用最大面额的纸钞即可.

```java
public static int payMoney(int money){
  int n = 5;
  //定义钱数与张数
  int count[] = {5,3,3,4,10};
  int value[] = {1,5,10,50,100};

  int num = 0;
  for (int i = n - 1;i >= 0;i--){
      int c = Math.min(money / value[i], count[i]);
      money = money - c*value[i];
      num += c;
  }
  return num;

}

```
