# TCP/IP协议族 和 HTTP

<https://juejin.im/post/598ba1d06fb9a03c4d6464ab>

本文档性能文档，也有对tcp/http的介绍 [性能文档](../performance.md#TCP)

- [TCP/IP](#TCP/IP)
- [HTTP](#HTTP)
- [HTTP2.0](#HTTP2.0)
- [http2对比http1](#http2对比http1)
- [知识点](#知识点)

***

## TCP/IP

- 通常使用的网络是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。

- TCP/IP是互联网相关的各类协议族的总称:

IP,PPPoE,DNS,UDP,FTP,SNMP,HTTP,FDDI,ICMP,IEEE 802.3,

- TCP/IP协议族按层次分别分为以下4层：

1. 应用层：应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务。比如：[FTP DNS HTTP SMTP POP3 SSH]

1. 传输层：传输层对上层应用层，提供处于网络链接中的两台计算机之间的数据传输。有两个性质不同的协议 [TCP UDP]

1. 网络层：网络层用来处理网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。[IP ICMP ARP RARP]

1. 数据链路层: 用来处理链接网络的硬件部分。包括控制操作系统，硬件的设备驱动，NIC，及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。

- 利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。

- IP协议

的作用是把各种数据包传送给对方。

- ARP

是一种用以解析地址的协议，根据通信方的IP地址就可以反查对应的MAC地址。

**TCP三次握手**

- 确保数据能到达目标，TCP协议采用了三次握手策略 :

syn ：（序号），SYNchronize

ack ：（确认号），acknowledgement number

1. 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

3. 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）

- 为什么要三次握手:

防止已失效的连接请求又传送到服务器端，因而产生错误

防止其中一方停止发送后，另一方持续等待。

## DNS

- DNS（Domain Name System）

DNS服务是和HTTP协议一样位于应用层的协议，它提供域名到IP地址之间的解析服务。

## URL URI

URL是URI的子集

## HTTP

<https://developer.mozilla.org/zh-CN/docs/Web/HTTP>

HyperText Transfer Protocal,超文本传输协议

HTTP是不保存状态的协议。每当有新的请求发生时，就会有对应的新响应产生。

HTTP1.1有了cookie，就可以管理状态了。

**支持的方法**

GET：获取资源

POST：获取实体主体

PUT：传输文件

HEAD：获得报文首部

DELETE：删除文件

OPTIONS：询问支持的方法

TRACE：追踪路径

**持久连接节省通信量**

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。

解决TCP连接问题，HTTP/1.1想出了持久连接（HTTP keep-alive）。

持久连接的特点：只要任意一端没有明确提出断开连接，则保持TCP连接状态。

持久连接旨在建立1次TCP连接后进行多次请求和响应的交互。减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的荷载。

在HTTP1.1中，所有连接默认都是持久连接。

**管线化**

管线化技术，不用等待响应亦可直接发送下一个请求。
同事并行发送多个请求，不需要一个接一个等待响应。

**cookie**

Cookie会根据从服务端发送的响应报文内的一个叫做Set-Cookie的首部信息字段，通知客户端保存Cookie。
下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入cookie值后发送出去。

**HTTP0.9**

最初的HTTP建议:

- 几个宏观的设计目标：  

1. 支持文件传输，
2. 能够请求对超文本文档的索引搜索
3. 格式化协商机制
4. 能够把客户端引导至不同的服务器

- 简单的原型：  
客户端请求是一个ASCII字符串  
客户端请求由一个回车符（CRLF）结尾  
服务器响应是一个ASCII字符流  
服务器响应的是一种超文本标记语言（HTML）  
连接在文档传输完毕后断开  

**HTTP1.0**

- 关键变化：

请求可以由于多行首部字段构成  
响应对象前面添加了一个响应状态行  
响应对象也有自己的由换行符分隔的首部字段  
响应对象不局限于超文本  
服务器和客户端之间的连接在每次请求之后都会关闭

> 事实上，HTTP中的 HTT（超文本传输）在协议出现后不久就用词不当了。在实践中，HTTP迅速发展为超媒体传输协议。

**HTTP1.1**

> HTTP1.1改变了HTTP协议的语义，默认使用持久连接。除非明确告知（connection:close 首部），否则服务器会保持连接打开。  
移植到1.0上，通过Connection:Keep-Alive 首部启用。如果是1.1不需要这个头部。
> 厘清了之前版本中很多有歧义的地方，而且还加入了很多重要的性能优化：持久连接，分块编码传输，字节范围请求，增强的缓存机制，传输编码及请求管道。

**状态码**

- 1xx（信息）

接收的请求正在处理

- 2xx（成功）

请求正常处理完毕

200: 从客户端发来的请求在服务器端被正常处理了

204: 已成功处理，返回报文不含实体。一般只需要客户端向服务端发送信息，而对客户端不需要发送新信息

206: 只请求部分资源

- 3xx（重定向）

需要进行附加操作以完成请求

301: Moved Permanently。资源已经被永久分配新的URI，以后应使用新URI。

302: Found。临时性重定向。资源已经被分配新的URI，希望用户本次使用新URI访问。

303: See Other。请求资源存在另一个URI，应使用GET定向获取请求的资源。

304: Not Modified。服务器资源未改变，直接使用客户端未过期的缓存。

- 4xx（客户端错误）

这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体。

400: Bad Request。请求报文中存在语法错误。

401: Unauthorized。需要认证

403: Forbidden。访问资源被服务器拒绝。访问权限问题。

404: Not Found。无法找到请求资源。

- 5xx（服务器错误）

这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。 并且响应消息体中应当给出理由，除非是HEAD请求

500: Internal Server Error。服务器执行请求时发生错误。

503: Service Unavailable。服务器停机中，无法处理请求。

**header**

- 请求

> withCredentials

withCredentials设置为true，可以向服务器发送cookies

- 响应

1. Access-Control-Allow-Origin

2. Access-Control-Expose-Headers

在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头，Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。

```sh
Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header
```

3. Access-Control-Max-Age

Access-Control-Max-Age 头指定了preflight请求的结果能够被缓存多久，请参考本文在前面提到的preflight例子。

```sh
Access-Control-Max-Age: <delta-seconds>
```

4. Access-Control-Allow-Methods

Access-Control-Allow-Methods 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。

5. Access-Control-Allow-Headers

Access-Control-Allow-Headers 首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。

## HTTP2.0

改进传输性能,实现低延迟和高吞吐量。

现有的网站和应用，无需做任何更改都可以在HTTP2.0上跑起来

HTTP2.0的目标:

1.支持请求与响应的多路复用来减少延迟  
2.通过压缩HTTP首部字段将协议开销降至最低。  
3.同时增加对请求优先级和服务器推送的支持

**二进制分帧层**

HTTP的语义，包括各种动词，方法，首部都不受影响，不同的是传输期间对他们的编码方式变了。HTTP1.x以换行符作为纯文本的分隔符，而HTTP2.0将所有传输的信息分隔为更小的消息和帧，并对他们采用二进制格式的编码

- 流,消息,帧:

流：已建立的连接上的双向字节流

消息：与逻辑消息对应的完整的一系列数据帧

帧： HTTP2.0通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流

所有HTTP2.0通信都在同一个连接上完成，这个连接可以承载任意数量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。

- 几个概念点：

  1. 所有的通信都在一个TCP连接上完成
  2. 流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标示符（1，2，。。。N）；
  3. 消息是指逻辑上的HTTP消息，比如请求，相应等，由一或多个帧组成
  4. 帧是最小的通信单位，承载着特定类型的数据，如HTTP首部，负荷，等等。

**多向请求与响应**

巨大的性能提升：

  1. 可以并行交错地发送请求，请求之间互不影响
  2. 可以并行交错地发送响应，响应之间互不影响
  3. 只使用一个连接即可并行发送多个请求和响应
  4. 消除不必要的延迟，从而减少页面加载的时间
  5. 不必再为绕过HTTP1.x限制而多做很多工作

**请求优先级**

每个流都可以带有一个31比特的优先值。0表示最高优先级，2（31）- 1表示最低优先级。

HTTP2.0没有规定处理优先级的具体算法。策略：客户端应该明确指定优先值，服务器应该根据该值处理和交付数据。

服务器可以而且应该交错发送不同优先级别的帧。既避免队首阻塞，又高效利用底层连接。

**每个来源一个连接**

不仅减少网络延迟，还有助于提高吞吐量和降低运营成本。

**流量控制**

优先级可以决定交付次序，而流量控制则可以控制HTTP2.0连接中每个流占用的资源：接收方可以针对特定的流广播较低的窗口大小，以限制它的传输速度。

HTTP2.0为数据流和连接的流量控制提供了一个简单的机制：

  1. 流量控制基于每一跳进行，而非端到端的控制
  2. 流量控制基于窗口更新帧进行，即接收广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节
  3. 流量控制窗口大小通过WINDOW_UPDATE帧更新，这个字段指定了流ID和窗口大小递增值
  4. 流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口的大小。
  5. 流量控制可以由接收方禁用，包括针对个别的流和针对整个连接

**服务器推送**

在HTTP2.0中，把资源通过HTTP推送给客户端，有以下好处：

  1. 客户端可以缓存推送过来的资源
  2. 客户端可以拒绝推送过来的资源
  3. 推送资源可以由不同的页面共享
  4. 服务器可以按照优先级推送资源

理论上，除了只有某页面需要的插入资源，之外的所有应用都应该使用HTTP2.0服务器推送。

推送资源直接进入客户端，不存在客户端API或Javascript回调方法等通知机制，可以用于确定资源何时到达。

**首部压缩**

- HTTP2.0在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送
- 首部表在HTTP2.0的连续存续期内始终存在，由客户端和服务器共同渐进地更新
- 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值。

**有效的HTTP2.0升级与发现**

**部署:**

参考NGINX白皮书，NGINX配置HTTP2.0官方指南 <https://www.nginx.com/blog/nginx-1-9-5/。>

部署博客：<https://www.liangzl.com/get-article-detail-594.html>

## http2对比http1

**多路复用**

HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；

**二进制分帧**

单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大

由于 TCP 连接的减少而使网络拥塞状况得以改善,同时慢启动时间的减少,使拥塞和丢包恢复速度更快

**首部压缩**

**服务器推送**

服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度

## POST和GET

### 区别

注意：以下描述有问题，应该是url传参和data传参区别，并不是get和post

```
大小方面: GET传输一般2M，POST没有大小限制

安全方面: GET通过url明文传输，POST通过body传输，本身都不安全，因为HTTP就是明文传输。

浏览器记录: GET请求浏览器会记录，POST不会

浏览器后退: GET无害，POST会再次提交

浏览器收藏: GET可以收藏，POST不可以

浏览器缓存: GET可以缓存，POST不会

编码方式: GET通过url编码，POST支持多种编码

TCP数据包: GET产生一个数据包，POST产生2个数据包

使用方式(习惯上讲): GET主要拉取数据，POST主要提交保存数据
```

### url长度限制

实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:
